{
  "version": 3,
  "sources": ["../../src/enums/transformation-type.enum.ts", "../../src/MetadataStorage.ts", "../../src/storage.ts", "../../src/utils/get-global.util.ts", "../../src/utils/is-promise.util.ts", "../../src/TransformOperationExecutor.ts", "../../src/constants/default-options.constant.ts", "../../src/ClassTransformer.ts", "../../src/decorators/exclude.decorator.ts", "../../src/decorators/expose.decorator.ts", "../../src/decorators/transform-instance-to-instance.decorator.ts", "../../src/decorators/transform-instance-to-plain.decorator.ts", "../../src/decorators/transform-plain-to-instance.decorator.ts", "../../src/decorators/transform.decorator.ts", "../../src/decorators/type.decorator.ts", "../../src/index.ts"],
  "sourcesContent": ["export enum TransformationType {\n  PLAIN_TO_CLASS,\n  CLASS_TO_PLAIN,\n  CLASS_TO_CLASS,\n}\n", "import { TypeMetadata, ExposeMetadata, ExcludeMetadata, TransformMetadata } from './interfaces';\nimport { TransformationType } from './enums';\n\n/**\n * Storage all library metadata.\n */\nexport class MetadataStorage {\n  // -------------------------------------------------------------------------\n  // Properties\n  // -------------------------------------------------------------------------\n\n  private _typeMetadatas = new Map<Function, Map<string, TypeMetadata>>();\n  private _transformMetadatas = new Map<Function, Map<string, TransformMetadata[]>>();\n  private _exposeMetadatas = new Map<Function, Map<string, ExposeMetadata>>();\n  private _excludeMetadatas = new Map<Function, Map<string, ExcludeMetadata>>();\n  private _ancestorsMap = new Map<Function, Function[]>();\n\n  // -------------------------------------------------------------------------\n  // Adder Methods\n  // -------------------------------------------------------------------------\n\n  addTypeMetadata(metadata: TypeMetadata): void {\n    if (!this._typeMetadatas.has(metadata.target)) {\n      this._typeMetadatas.set(metadata.target, new Map<string, TypeMetadata>());\n    }\n    this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n  }\n\n  addTransformMetadata(metadata: TransformMetadata): void {\n    if (!this._transformMetadatas.has(metadata.target)) {\n      this._transformMetadatas.set(metadata.target, new Map<string, TransformMetadata[]>());\n    }\n    if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {\n      this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);\n    }\n    this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);\n  }\n\n  addExposeMetadata(metadata: ExposeMetadata): void {\n    if (!this._exposeMetadatas.has(metadata.target)) {\n      this._exposeMetadatas.set(metadata.target, new Map<string, ExposeMetadata>());\n    }\n    this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n  }\n\n  addExcludeMetadata(metadata: ExcludeMetadata): void {\n    if (!this._excludeMetadatas.has(metadata.target)) {\n      this._excludeMetadatas.set(metadata.target, new Map<string, ExcludeMetadata>());\n    }\n    this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n  }\n\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  findTransformMetadatas(\n    target: Function,\n    propertyName: string,\n    transformationType: TransformationType\n  ): TransformMetadata[] {\n    return this.findMetadatas(this._transformMetadatas, target, propertyName).filter(metadata => {\n      if (!metadata.options) return true;\n      if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;\n\n      if (metadata.options.toClassOnly === true) {\n        return (\n          transformationType === TransformationType.CLASS_TO_CLASS ||\n          transformationType === TransformationType.PLAIN_TO_CLASS\n        );\n      }\n      if (metadata.options.toPlainOnly === true) {\n        return transformationType === TransformationType.CLASS_TO_PLAIN;\n      }\n\n      return true;\n    });\n  }\n\n  findExcludeMetadata(target: Function, propertyName: string): ExcludeMetadata {\n    return this.findMetadata(this._excludeMetadatas, target, propertyName);\n  }\n\n  findExposeMetadata(target: Function, propertyName: string): ExposeMetadata {\n    return this.findMetadata(this._exposeMetadatas, target, propertyName);\n  }\n\n  findExposeMetadataByCustomName(target: Function, name: string): ExposeMetadata {\n    return this.getExposedMetadatas(target).find(metadata => {\n      return metadata.options && metadata.options.name === name;\n    });\n  }\n\n  findTypeMetadata(target: Function, propertyName: string): TypeMetadata {\n    return this.findMetadata(this._typeMetadatas, target, propertyName);\n  }\n\n  getStrategy(target: Function): 'excludeAll' | 'exposeAll' | 'none' {\n    const excludeMap = this._excludeMetadatas.get(target);\n    const exclude = excludeMap && excludeMap.get(undefined);\n    const exposeMap = this._exposeMetadatas.get(target);\n    const expose = exposeMap && exposeMap.get(undefined);\n    if ((exclude && expose) || (!exclude && !expose)) return 'none';\n    return exclude ? 'excludeAll' : 'exposeAll';\n  }\n\n  getExposedMetadatas(target: Function): ExposeMetadata[] {\n    return this.getMetadata(this._exposeMetadatas, target);\n  }\n\n  getExcludedMetadatas(target: Function): ExcludeMetadata[] {\n    return this.getMetadata(this._excludeMetadatas, target);\n  }\n\n  getExposedProperties(target: Function, transformationType: TransformationType): string[] {\n    return this.getExposedMetadatas(target)\n      .filter(metadata => {\n        if (!metadata.options) return true;\n        if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;\n\n        if (metadata.options.toClassOnly === true) {\n          return (\n            transformationType === TransformationType.CLASS_TO_CLASS ||\n            transformationType === TransformationType.PLAIN_TO_CLASS\n          );\n        }\n        if (metadata.options.toPlainOnly === true) {\n          return transformationType === TransformationType.CLASS_TO_PLAIN;\n        }\n\n        return true;\n      })\n      .map(metadata => metadata.propertyName);\n  }\n\n  getExcludedProperties(target: Function, transformationType: TransformationType): string[] {\n    return this.getExcludedMetadatas(target)\n      .filter(metadata => {\n        if (!metadata.options) return true;\n        if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;\n\n        if (metadata.options.toClassOnly === true) {\n          return (\n            transformationType === TransformationType.CLASS_TO_CLASS ||\n            transformationType === TransformationType.PLAIN_TO_CLASS\n          );\n        }\n        if (metadata.options.toPlainOnly === true) {\n          return transformationType === TransformationType.CLASS_TO_PLAIN;\n        }\n\n        return true;\n      })\n      .map(metadata => metadata.propertyName);\n  }\n\n  clear(): void {\n    this._typeMetadatas.clear();\n    this._exposeMetadatas.clear();\n    this._excludeMetadatas.clear();\n    this._ancestorsMap.clear();\n  }\n\n  // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n\n  private getMetadata<T extends { target: Function; propertyName: string }>(\n    metadatas: Map<Function, Map<string, T>>,\n    target: Function\n  ): T[] {\n    const metadataFromTargetMap = metadatas.get(target);\n    let metadataFromTarget: T[];\n    if (metadataFromTargetMap) {\n      metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter(meta => meta.propertyName !== undefined);\n    }\n    const metadataFromAncestors: T[] = [];\n    for (const ancestor of this.getAncestors(target)) {\n      const ancestorMetadataMap = metadatas.get(ancestor);\n      if (ancestorMetadataMap) {\n        const metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter(\n          meta => meta.propertyName !== undefined\n        );\n        metadataFromAncestors.push(...metadataFromAncestor);\n      }\n    }\n    return metadataFromAncestors.concat(metadataFromTarget || []);\n  }\n\n  private findMetadata<T extends { target: Function; propertyName: string }>(\n    metadatas: Map<Function, Map<string, T>>,\n    target: Function,\n    propertyName: string\n  ): T {\n    const metadataFromTargetMap = metadatas.get(target);\n    if (metadataFromTargetMap) {\n      const metadataFromTarget = metadataFromTargetMap.get(propertyName);\n      if (metadataFromTarget) {\n        return metadataFromTarget;\n      }\n    }\n    for (const ancestor of this.getAncestors(target)) {\n      const ancestorMetadataMap = metadatas.get(ancestor);\n      if (ancestorMetadataMap) {\n        const ancestorResult = ancestorMetadataMap.get(propertyName);\n        if (ancestorResult) {\n          return ancestorResult;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  private findMetadatas<T extends { target: Function; propertyName: string }>(\n    metadatas: Map<Function, Map<string, T[]>>,\n    target: Function,\n    propertyName: string\n  ): T[] {\n    const metadataFromTargetMap = metadatas.get(target);\n    let metadataFromTarget: T[];\n    if (metadataFromTargetMap) {\n      metadataFromTarget = metadataFromTargetMap.get(propertyName);\n    }\n    const metadataFromAncestorsTarget: T[] = [];\n    for (const ancestor of this.getAncestors(target)) {\n      const ancestorMetadataMap = metadatas.get(ancestor);\n      if (ancestorMetadataMap) {\n        if (ancestorMetadataMap.has(propertyName)) {\n          metadataFromAncestorsTarget.push(...ancestorMetadataMap.get(propertyName));\n        }\n      }\n    }\n    return metadataFromAncestorsTarget\n      .slice()\n      .reverse()\n      .concat((metadataFromTarget || []).slice().reverse());\n  }\n\n  private getAncestors(target: Function): Function[] {\n    if (!target) return [];\n    if (!this._ancestorsMap.has(target)) {\n      const ancestors: Function[] = [];\n      for (\n        let baseClass = Object.getPrototypeOf(target.prototype.constructor);\n        typeof baseClass.prototype !== 'undefined';\n        baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)\n      ) {\n        ancestors.push(baseClass);\n      }\n      this._ancestorsMap.set(target, ancestors);\n    }\n    return this._ancestorsMap.get(target);\n  }\n}\n", "import { MetadataStorage } from './MetadataStorage';\n\n/**\n * Default metadata storage is used as singleton and can be used to storage all metadatas.\n */\nexport const defaultMetadataStorage = new MetadataStorage();\n", "/**\n * This function returns the global object across Node and browsers.\n *\n * Note: `globalThis` is the standardized approach however it has been added to\n * Node.js in version 12. We need to include this snippet until Node 12 EOL.\n */\nexport function getGlobal() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore: Cannot find name 'window'.\n  if (typeof window !== 'undefined') {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore: Cannot find name 'window'.\n    return window;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore: Cannot find name 'self'.\n  if (typeof self !== 'undefined') {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore: Cannot find name 'self'.\n    return self;\n  }\n}\n", "export function isPromise<T>(p: any): p is Promise<T> {\n  return p !== null && typeof p === 'object' && typeof p.then === 'function';\n}\n", "import { defaultMetadataStorage } from './storage';\nimport { ClassTransformOptions, TypeHelpOptions, TypeMetadata, TypeOptions } from './interfaces';\nimport { TransformationType } from './enums';\nimport { getGlobal, isPromise } from './utils';\n\nfunction instantiateArrayType(arrayType: Function): Array<any> | Set<any> {\n  const array = new (arrayType as any)();\n  if (!(array instanceof Set) && !('push' in array)) {\n    return [];\n  }\n  return array;\n}\n\nexport class TransformOperationExecutor {\n  // -------------------------------------------------------------------------\n  // Private Properties\n  // -------------------------------------------------------------------------\n\n  private recursionStack = new Set<Record<string, any>>();\n\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n\n  constructor(private transformationType: TransformationType, private options: ClassTransformOptions) {}\n\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  transform(\n    source: Record<string, any> | Record<string, any>[] | any,\n    value: Record<string, any> | Record<string, any>[] | any,\n    targetType: Function | TypeMetadata,\n    arrayType: Function,\n    isMap: boolean,\n    level: number = 0\n  ): any {\n    if (Array.isArray(value) || value instanceof Set) {\n      const newValue =\n        arrayType && this.transformationType === TransformationType.PLAIN_TO_CLASS\n          ? instantiateArrayType(arrayType)\n          : [];\n      (value as any[]).forEach((subValue, index) => {\n        const subSource = source ? source[index] : undefined;\n        if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {\n          let realTargetType;\n          if (\n            typeof targetType !== 'function' &&\n            targetType &&\n            targetType.options &&\n            targetType.options.discriminator &&\n            targetType.options.discriminator.property &&\n            targetType.options.discriminator.subTypes\n          ) {\n            if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n              realTargetType = targetType.options.discriminator.subTypes.find(\n                subType =>\n                  subType.name === subValue[(targetType as { options: TypeOptions }).options.discriminator.property]\n              );\n              const options: TypeHelpOptions = { newObject: newValue, object: subValue, property: undefined };\n              const newType = targetType.typeFunction(options);\n              realTargetType === undefined ? (realTargetType = newType) : (realTargetType = realTargetType.value);\n              if (!targetType.options.keepDiscriminatorProperty)\n                delete subValue[targetType.options.discriminator.property];\n            }\n\n            if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n              realTargetType = subValue.constructor;\n            }\n            if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n              subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find(\n                subType => subType.value === subValue.constructor\n              ).name;\n            }\n          } else {\n            realTargetType = targetType;\n          }\n          const value = this.transform(\n            subSource,\n            subValue,\n            realTargetType,\n            undefined,\n            subValue instanceof Map,\n            level + 1\n          );\n\n          if (newValue instanceof Set) {\n            newValue.add(value);\n          } else {\n            newValue.push(value);\n          }\n        } else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n          if (newValue instanceof Set) {\n            newValue.add(subValue);\n          } else {\n            newValue.push(subValue);\n          }\n        }\n      });\n      return newValue;\n    } else if (targetType === String && !isMap) {\n      if (value === null || value === undefined) return value;\n      return String(value);\n    } else if (targetType === Number && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Number(value);\n    } else if (targetType === Boolean && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Boolean(value);\n    } else if ((targetType === Date || value instanceof Date) && !isMap) {\n      if (value instanceof Date) {\n        return new Date(value.valueOf());\n      }\n      if (value === null || value === undefined) return value;\n      return new Date(value);\n    } else if (!!getGlobal().Buffer && (targetType === Buffer || value instanceof Buffer) && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Buffer.from(value);\n    } else if (isPromise(value) && !isMap) {\n      return new Promise((resolve, reject) => {\n        value.then(\n          (data: any) => resolve(this.transform(undefined, data, targetType, undefined, undefined, level + 1)),\n          reject\n        );\n      });\n    } else if (!isMap && value !== null && typeof value === 'object' && typeof value.then === 'function') {\n      // Note: We should not enter this, as promise has been handled above\n      // This option simply returns the Promise preventing a JS error from happening and should be an inaccessible path.\n      return value; // skip promise transformation\n    } else if (typeof value === 'object' && value !== null) {\n      // try to guess the type\n      if (!targetType && value.constructor !== Object /* && TransformationType === TransformationType.CLASS_TO_PLAIN*/)\n        if (!Array.isArray(value) && value.constructor === Array) {\n          // Somebody attempts to convert special Array like object to Array, eg:\n          // const evilObject = { '100000000': '100000000', __proto__: [] };\n          // This could be used to cause Denial-of-service attack so we don't allow it.\n          // See prevent-array-bomb.spec.ts for more details.\n        } else {\n          // We are good we can use the built-in constructor\n          targetType = value.constructor;\n        }\n      if (!targetType && source) targetType = source.constructor;\n\n      if (this.options.enableCircularCheck) {\n        // add transformed type to prevent circular references\n        this.recursionStack.add(value);\n      }\n\n      const keys = this.getKeys(targetType as Function, value, isMap);\n      let newValue: any = source ? source : {};\n      if (\n        !source &&\n        (this.transformationType === TransformationType.PLAIN_TO_CLASS ||\n          this.transformationType === TransformationType.CLASS_TO_CLASS)\n      ) {\n        if (isMap) {\n          newValue = new Map();\n        } else if (targetType) {\n          newValue = new (targetType as any)();\n        } else {\n          newValue = {};\n        }\n      }\n\n      // traverse over keys\n      for (const key of keys) {\n        if (key === '__proto__' || key === 'constructor') {\n          continue;\n        }\n\n        const valueKey = key;\n        let newValueKey = key,\n          propertyName = key;\n        if (!this.options.ignoreDecorators && targetType) {\n          if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n            const exposeMetadata = defaultMetadataStorage.findExposeMetadataByCustomName(targetType as Function, key);\n            if (exposeMetadata) {\n              propertyName = exposeMetadata.propertyName;\n              newValueKey = exposeMetadata.propertyName;\n            }\n          } else if (\n            this.transformationType === TransformationType.CLASS_TO_PLAIN ||\n            this.transformationType === TransformationType.CLASS_TO_CLASS\n          ) {\n            const exposeMetadata = defaultMetadataStorage.findExposeMetadata(targetType as Function, key);\n            if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n              newValueKey = exposeMetadata.options.name;\n            }\n          }\n        }\n\n        // get a subvalue\n        let subValue: any = undefined;\n        if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n          /**\n           * This section is added for the following report:\n           * https://github.com/typestack/class-transformer/issues/596\n           *\n           * We should not call functions or constructors when transforming to class.\n           */\n          subValue = value[valueKey];\n        } else {\n          if (value instanceof Map) {\n            subValue = value.get(valueKey);\n          } else if (value[valueKey] instanceof Function) {\n            subValue = value[valueKey]();\n          } else {\n            subValue = value[valueKey];\n          }\n        }\n\n        // determine a type\n        let type: any = undefined,\n          isSubValueMap = subValue instanceof Map;\n        if (targetType && isMap) {\n          type = targetType;\n        } else if (targetType) {\n          const metadata = defaultMetadataStorage.findTypeMetadata(targetType as Function, propertyName);\n          if (metadata) {\n            const options: TypeHelpOptions = { newObject: newValue, object: value, property: propertyName };\n            const newType = metadata.typeFunction ? metadata.typeFunction(options) : metadata.reflectedType;\n            if (\n              metadata.options &&\n              metadata.options.discriminator &&\n              metadata.options.discriminator.property &&\n              metadata.options.discriminator.subTypes\n            ) {\n              if (!(value[valueKey] instanceof Array)) {\n                if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                  type = metadata.options.discriminator.subTypes.find(subType => {\n                    if (subValue && subValue instanceof Object && metadata.options.discriminator.property in subValue) {\n                      return subType.name === subValue[metadata.options.discriminator.property];\n                    }\n                  });\n                  type === undefined ? (type = newType) : (type = type.value);\n                  if (!metadata.options.keepDiscriminatorProperty) {\n                    if (subValue && subValue instanceof Object && metadata.options.discriminator.property in subValue) {\n                      delete subValue[metadata.options.discriminator.property];\n                    }\n                  }\n                }\n                if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                  type = subValue.constructor;\n                }\n                if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                  if (subValue) {\n                    subValue[metadata.options.discriminator.property] = metadata.options.discriminator.subTypes.find(\n                      subType => subType.value === subValue.constructor\n                    ).name;\n                  }\n                }\n              } else {\n                type = metadata;\n              }\n            } else {\n              type = newType;\n            }\n            isSubValueMap = isSubValueMap || metadata.reflectedType === Map;\n          } else if (this.options.targetMaps) {\n            // try to find a type in target maps\n            this.options.targetMaps\n              .filter(map => map.target === targetType && !!map.properties[propertyName])\n              .forEach(map => (type = map.properties[propertyName]));\n          } else if (\n            this.options.enableImplicitConversion &&\n            this.transformationType === TransformationType.PLAIN_TO_CLASS\n          ) {\n            // if we have no registererd type via the @Type() decorator then we check if we have any\n            // type declarations in reflect-metadata (type declaration is emited only if some decorator is added to the property.)\n            const reflectedType = (Reflect as any).getMetadata(\n              'design:type',\n              (targetType as Function).prototype,\n              propertyName\n            );\n\n            if (reflectedType) {\n              type = reflectedType;\n            }\n          }\n        }\n\n        // if value is an array try to get its custom array type\n        const arrayType = Array.isArray(value[valueKey])\n          ? this.getReflectedType(targetType as Function, propertyName)\n          : undefined;\n\n        // const subValueKey = TransformationType === TransformationType.PLAIN_TO_CLASS && newKeyName ? newKeyName : key;\n        const subSource = source ? source[valueKey] : undefined;\n\n        // if its deserialization then type if required\n        // if we uncomment this types like string[] will not work\n        // if (this.transformationType === TransformationType.PLAIN_TO_CLASS && !type && subValue instanceof Object && !(subValue instanceof Date))\n        //     throw new Error(`Cannot determine type for ${(targetType as any).name }.${propertyName}, did you forget to specify a @Type?`);\n\n        // if newValue is a source object that has method that match newKeyName then skip it\n        if (newValue.constructor.prototype) {\n          const descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);\n          if (\n            (this.transformationType === TransformationType.PLAIN_TO_CLASS ||\n              this.transformationType === TransformationType.CLASS_TO_CLASS) &&\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            ((descriptor && !descriptor.set) || newValue[newValueKey] instanceof Function)\n          )\n            //  || TransformationType === TransformationType.CLASS_TO_CLASS\n            continue;\n        }\n\n        if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {\n          const transformKey = this.transformationType === TransformationType.PLAIN_TO_CLASS ? newValueKey : key;\n          let finalValue;\n\n          if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n            // Get original value\n            finalValue = value[transformKey];\n            // Apply custom transformation\n            finalValue = this.applyCustomTransformations(\n              finalValue,\n              targetType as Function,\n              transformKey,\n              value,\n              this.transformationType\n            );\n            // If nothing change, it means no custom transformation was applied, so use the subValue.\n            finalValue = value[transformKey] === finalValue ? subValue : finalValue;\n            // Apply the default transformation\n            finalValue = this.transform(subSource, finalValue, type, arrayType, isSubValueMap, level + 1);\n          } else {\n            if (subValue === undefined && this.options.exposeDefaultValues) {\n              // Set default value if nothing provided\n              finalValue = newValue[newValueKey];\n            } else {\n              finalValue = this.transform(subSource, subValue, type, arrayType, isSubValueMap, level + 1);\n              finalValue = this.applyCustomTransformations(\n                finalValue,\n                targetType as Function,\n                transformKey,\n                value,\n                this.transformationType\n              );\n            }\n          }\n\n          if (finalValue !== undefined || this.options.exposeUnsetFields) {\n            if (newValue instanceof Map) {\n              newValue.set(newValueKey, finalValue);\n            } else {\n              newValue[newValueKey] = finalValue;\n            }\n          }\n        } else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n          let finalValue = subValue;\n          finalValue = this.applyCustomTransformations(\n            finalValue,\n            targetType as Function,\n            key,\n            value,\n            this.transformationType\n          );\n          if (finalValue !== undefined || this.options.exposeUnsetFields) {\n            if (newValue instanceof Map) {\n              newValue.set(newValueKey, finalValue);\n            } else {\n              newValue[newValueKey] = finalValue;\n            }\n          }\n        }\n      }\n\n      if (this.options.enableCircularCheck) {\n        this.recursionStack.delete(value);\n      }\n\n      return newValue;\n    } else {\n      return value;\n    }\n  }\n\n  private applyCustomTransformations(\n    value: any,\n    target: Function,\n    key: string,\n    obj: any,\n    transformationType: TransformationType\n  ): boolean {\n    let metadatas = defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType);\n\n    // apply versioning options\n    if (this.options.version !== undefined) {\n      metadatas = metadatas.filter(metadata => {\n        if (!metadata.options) return true;\n\n        return this.checkVersion(metadata.options.since, metadata.options.until);\n      });\n    }\n\n    // apply grouping options\n    if (this.options.groups && this.options.groups.length) {\n      metadatas = metadatas.filter(metadata => {\n        if (!metadata.options) return true;\n\n        return this.checkGroups(metadata.options.groups);\n      });\n    } else {\n      metadatas = metadatas.filter(metadata => {\n        return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;\n      });\n    }\n\n    metadatas.forEach(metadata => {\n      value = metadata.transformFn({ value, key, obj, type: transformationType, options: this.options });\n    });\n\n    return value;\n  }\n\n  // preventing circular references\n  private isCircular(object: Record<string, any>): boolean {\n    return this.recursionStack.has(object);\n  }\n\n  private getReflectedType(target: Function, propertyName: string): Function | undefined {\n    if (!target) return undefined;\n    const meta = defaultMetadataStorage.findTypeMetadata(target, propertyName);\n    return meta ? meta.reflectedType : undefined;\n  }\n\n  private getKeys(target: Function, object: Record<string, any>, isMap: boolean): string[] {\n    // determine exclusion strategy\n    let strategy = defaultMetadataStorage.getStrategy(target);\n    if (strategy === 'none') strategy = this.options.strategy || 'exposeAll'; // exposeAll is default strategy\n\n    // get all keys that need to expose\n    let keys: any[] = [];\n    if (strategy === 'exposeAll' || isMap) {\n      if (object instanceof Map) {\n        keys = Array.from(object.keys());\n      } else {\n        keys = Object.keys(object);\n      }\n    }\n\n    if (isMap) {\n      // expose & exclude do not apply for map keys only to fields\n      return keys;\n    }\n\n    /**\n     * If decorators are ignored but we don't want the extraneous values, then we use the\n     * metadata to decide which property is needed, but doesn't apply the decorator effect.\n     */\n    if (this.options.ignoreDecorators && this.options.excludeExtraneousValues && target) {\n      const exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);\n      const excludedProperties = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);\n      keys = [...exposedProperties, ...excludedProperties];\n    }\n\n    if (!this.options.ignoreDecorators && target) {\n      // add all exposed to list of keys\n      let exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);\n      if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n        exposedProperties = exposedProperties.map(key => {\n          const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n          if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n            return exposeMetadata.options.name;\n          }\n\n          return key;\n        });\n      }\n      if (this.options.excludeExtraneousValues) {\n        keys = exposedProperties;\n      } else {\n        keys = keys.concat(exposedProperties);\n      }\n\n      // exclude excluded properties\n      const excludedProperties = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);\n      if (excludedProperties.length > 0) {\n        keys = keys.filter(key => {\n          return !excludedProperties.includes(key);\n        });\n      }\n\n      // apply versioning options\n      if (this.options.version !== undefined) {\n        keys = keys.filter(key => {\n          const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n          if (!exposeMetadata || !exposeMetadata.options) return true;\n\n          return this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);\n        });\n      }\n\n      // apply grouping options\n      if (this.options.groups && this.options.groups.length) {\n        keys = keys.filter(key => {\n          const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n          if (!exposeMetadata || !exposeMetadata.options) return true;\n\n          return this.checkGroups(exposeMetadata.options.groups);\n        });\n      } else {\n        keys = keys.filter(key => {\n          const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n          return (\n            !exposeMetadata ||\n            !exposeMetadata.options ||\n            !exposeMetadata.options.groups ||\n            !exposeMetadata.options.groups.length\n          );\n        });\n      }\n    }\n\n    // exclude prefixed properties\n    if (this.options.excludePrefixes && this.options.excludePrefixes.length) {\n      keys = keys.filter(key =>\n        this.options.excludePrefixes.every(prefix => {\n          return key.substr(0, prefix.length) !== prefix;\n        })\n      );\n    }\n\n    // make sure we have unique keys\n    keys = keys.filter((key, index, self) => {\n      return self.indexOf(key) === index;\n    });\n\n    return keys;\n  }\n\n  private checkVersion(since: number, until: number): boolean {\n    let decision = true;\n    if (decision && since) decision = this.options.version >= since;\n    if (decision && until) decision = this.options.version < until;\n\n    return decision;\n  }\n\n  private checkGroups(groups: string[]): boolean {\n    if (!groups) return true;\n\n    return this.options.groups.some(optionGroup => groups.includes(optionGroup));\n  }\n}\n", "import { ClassTransformOptions } from '../interfaces/class-transformer-options.interface';\n\n/**\n * These are the default options used by any transformation operation.\n */\nexport const defaultOptions: Partial<ClassTransformOptions> = {\n  enableCircularCheck: false,\n  enableImplicitConversion: false,\n  excludeExtraneousValues: false,\n  excludePrefixes: undefined,\n  exposeDefaultValues: false,\n  exposeUnsetFields: true,\n  groups: undefined,\n  ignoreDecorators: false,\n  strategy: undefined,\n  targetMaps: undefined,\n  version: undefined,\n};\n", "import { ClassTransformOptions } from './interfaces';\nimport { TransformOperationExecutor } from './TransformOperationExecutor';\nimport { TransformationType } from './enums';\nimport { ClassConstructor } from './interfaces';\nimport { defaultOptions } from './constants/default-options.constant';\n\nexport class ClassTransformer {\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Converts class (constructor) object to plain (literal) object. Also works with arrays.\n   */\n  instanceToPlain<T extends Record<string, any>>(object: T, options?: ClassTransformOptions): Record<string, any>;\n  instanceToPlain<T extends Record<string, any>>(object: T[], options?: ClassTransformOptions): Record<string, any>[];\n  instanceToPlain<T extends Record<string, any>>(\n    object: T | T[],\n    options?: ClassTransformOptions\n  ): Record<string, any> | Record<string, any>[] {\n    const executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, {\n      ...defaultOptions,\n      ...options,\n    });\n    return executor.transform(undefined, object, undefined, undefined, undefined, undefined);\n  }\n\n  /**\n   * Converts class (constructor) object to plain (literal) object.\n   * Uses given plain object as source object (it means fills given plain object with data from class object).\n   * Also works with arrays.\n   */\n  classToPlainFromExist<T extends Record<string, any>, P>(\n    object: T,\n    plainObject: P,\n    options?: ClassTransformOptions\n  ): T;\n  classToPlainFromExist<T extends Record<string, any>, P>(\n    object: T,\n    plainObjects: P[],\n    options?: ClassTransformOptions\n  ): T[];\n  classToPlainFromExist<T extends Record<string, any>, P>(\n    object: T,\n    plainObject: P | P[],\n    options?: ClassTransformOptions\n  ): T | T[] {\n    const executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, {\n      ...defaultOptions,\n      ...options,\n    });\n    return executor.transform(plainObject, object, undefined, undefined, undefined, undefined);\n  }\n\n  /**\n   * Converts plain (literal) object to class (constructor) object. Also works with arrays.\n   */\n  plainToInstance<T extends Record<string, any>, V extends Array<any>>(\n    cls: ClassConstructor<T>,\n    plain: V,\n    options?: ClassTransformOptions\n  ): T[];\n  plainToInstance<T extends Record<string, any>, V>(\n    cls: ClassConstructor<T>,\n    plain: V,\n    options?: ClassTransformOptions\n  ): T;\n  plainToInstance<T extends Record<string, any>, V>(\n    cls: ClassConstructor<T>,\n    plain: V | V[],\n    options?: ClassTransformOptions\n  ): T | T[] {\n    const executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, {\n      ...defaultOptions,\n      ...options,\n    });\n    return executor.transform(undefined, plain, cls, undefined, undefined, undefined);\n  }\n\n  /**\n   * Converts plain (literal) object to class (constructor) object.\n   * Uses given object as source object (it means fills given object with data from plain object).\n   * Also works with arrays.\n   */\n  plainToClassFromExist<T extends Record<string, any>, V extends Array<any>>(\n    clsObject: T,\n    plain: V,\n    options?: ClassTransformOptions\n  ): T;\n  plainToClassFromExist<T extends Record<string, any>, V>(clsObject: T, plain: V, options?: ClassTransformOptions): T[];\n  plainToClassFromExist<T extends Record<string, any>, V>(\n    clsObject: T,\n    plain: V | V[],\n    options?: ClassTransformOptions\n  ): T | T[] {\n    const executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, {\n      ...defaultOptions,\n      ...options,\n    });\n    return executor.transform(clsObject, plain, undefined, undefined, undefined, undefined);\n  }\n\n  /**\n   * Converts class (constructor) object to new class (constructor) object. Also works with arrays.\n   */\n  instanceToInstance<T>(object: T, options?: ClassTransformOptions): T;\n  instanceToInstance<T>(object: T[], options?: ClassTransformOptions): T[];\n  instanceToInstance<T>(object: T | T[], options?: ClassTransformOptions): T | T[] {\n    const executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, {\n      ...defaultOptions,\n      ...options,\n    });\n    return executor.transform(undefined, object, undefined, undefined, undefined, undefined);\n  }\n\n  /**\n   * Converts class (constructor) object to plain (literal) object.\n   * Uses given plain object as source object (it means fills given plain object with data from class object).\n   * Also works with arrays.\n   */\n  classToClassFromExist<T>(object: T, fromObject: T, options?: ClassTransformOptions): T;\n  classToClassFromExist<T>(object: T, fromObjects: T[], options?: ClassTransformOptions): T[];\n  classToClassFromExist<T>(object: T, fromObject: T | T[], options?: ClassTransformOptions): T | T[] {\n    const executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, {\n      ...defaultOptions,\n      ...options,\n    });\n    return executor.transform(fromObject, object, undefined, undefined, undefined, undefined);\n  }\n\n  /**\n   * Serializes given object to a JSON string.\n   */\n  serialize<T>(object: T, options?: ClassTransformOptions): string;\n  serialize<T>(object: T[], options?: ClassTransformOptions): string;\n  serialize<T>(object: T | T[], options?: ClassTransformOptions): string {\n    return JSON.stringify(this.instanceToPlain(object, options));\n  }\n\n  /**\n   * Deserializes given JSON string to a object of the given class.\n   */\n  deserialize<T>(cls: ClassConstructor<T>, json: string, options?: ClassTransformOptions): T {\n    const jsonObject: T = JSON.parse(json);\n    return this.plainToInstance(cls, jsonObject, options);\n  }\n\n  /**\n   * Deserializes given JSON string to an array of objects of the given class.\n   */\n  deserializeArray<T>(cls: ClassConstructor<T>, json: string, options?: ClassTransformOptions): T[] {\n    const jsonObject: any[] = JSON.parse(json);\n    return this.plainToInstance(cls, jsonObject, options);\n  }\n}\n", "import { defaultMetadataStorage } from '../storage';\nimport { ExcludeOptions } from '../interfaces';\n\n/**\n * Marks the given class or property as excluded. By default the property is excluded in both\n * constructorToPlain and plainToConstructor transformations. It can be limited to only one direction\n * via using the `toPlainOnly` or `toClassOnly` option.\n *\n * Can be applied to class definitions and properties.\n */\nexport function Exclude(options: ExcludeOptions = {}): PropertyDecorator & ClassDecorator {\n  /**\n   * NOTE: The `propertyName` property must be marked as optional because\n   * this decorator used both as a class and a property decorator and the\n   * Typescript compiler will freak out if we make it mandatory as a class\n   * decorator only receives one parameter.\n   */\n  return function (object: any, propertyName?: string | Symbol): void {\n    defaultMetadataStorage.addExcludeMetadata({\n      target: object instanceof Function ? object : object.constructor,\n      propertyName: propertyName as string,\n      options,\n    });\n  };\n}\n", "import { defaultMetadataStorage } from '../storage';\nimport { ExposeOptions } from '../interfaces';\n\n/**\n * Marks the given class or property as included. By default the property is included in both\n * constructorToPlain and plainToConstructor transformations. It can be limited to only one direction\n * via using the `toPlainOnly` or `toClassOnly` option.\n *\n * Can be applied to class definitions and properties.\n */\nexport function Expose(options: ExposeOptions = {}): PropertyDecorator & ClassDecorator {\n  /**\n   * NOTE: The `propertyName` property must be marked as optional because\n   * this decorator used both as a class and a property decorator and the\n   * Typescript compiler will freak out if we make it mandatory as a class\n   * decorator only receives one parameter.\n   */\n  return function (object: any, propertyName?: string | Symbol): void {\n    defaultMetadataStorage.addExposeMetadata({\n      target: object instanceof Function ? object : object.constructor,\n      propertyName: propertyName as string,\n      options,\n    });\n  };\n}\n", "import { ClassTransformer } from '../ClassTransformer';\nimport { ClassTransformOptions } from '../interfaces';\n\n/**\n * Return the class instance only with the exposed properties.\n *\n * Can be applied to functions and getters/setters only.\n */\nexport function TransformInstanceToInstance(params?: ClassTransformOptions): MethodDecorator {\n  return function (target: Record<string, any>, propertyKey: string | Symbol, descriptor: PropertyDescriptor): void {\n    const classTransformer: ClassTransformer = new ClassTransformer();\n    const originalMethod = descriptor.value;\n\n    descriptor.value = function (...args: any[]): Record<string, any> {\n      const result: any = originalMethod.apply(this, args);\n      const isPromise =\n        !!result && (typeof result === 'object' || typeof result === 'function') && typeof result.then === 'function';\n      return isPromise\n        ? result.then((data: any) => classTransformer.instanceToInstance(data, params))\n        : classTransformer.instanceToInstance(result, params);\n    };\n  };\n}\n", "import { ClassTransformer } from '../ClassTransformer';\nimport { ClassTransformOptions } from '../interfaces';\n\n/**\n * Transform the object from class to plain object and return only with the exposed properties.\n *\n * Can be applied to functions and getters/setters only.\n */\nexport function TransformInstanceToPlain(params?: ClassTransformOptions): MethodDecorator {\n  return function (target: Record<string, any>, propertyKey: string | Symbol, descriptor: PropertyDescriptor): void {\n    const classTransformer: ClassTransformer = new ClassTransformer();\n    const originalMethod = descriptor.value;\n\n    descriptor.value = function (...args: any[]): Record<string, any> {\n      const result: any = originalMethod.apply(this, args);\n      const isPromise =\n        !!result && (typeof result === 'object' || typeof result === 'function') && typeof result.then === 'function';\n      return isPromise\n        ? result.then((data: any) => classTransformer.instanceToPlain(data, params))\n        : classTransformer.instanceToPlain(result, params);\n    };\n  };\n}\n", "import { ClassTransformer } from '../ClassTransformer';\nimport { ClassTransformOptions, ClassConstructor } from '../interfaces';\n\n/**\n * Return the class instance only with the exposed properties.\n *\n * Can be applied to functions and getters/setters only.\n */\nexport function TransformPlainToInstance(\n  classType: ClassConstructor<any>,\n  params?: ClassTransformOptions\n): MethodDecorator {\n  return function (target: Record<string, any>, propertyKey: string | Symbol, descriptor: PropertyDescriptor): void {\n    const classTransformer: ClassTransformer = new ClassTransformer();\n    const originalMethod = descriptor.value;\n\n    descriptor.value = function (...args: any[]): Record<string, any> {\n      const result: any = originalMethod.apply(this, args);\n      const isPromise =\n        !!result && (typeof result === 'object' || typeof result === 'function') && typeof result.then === 'function';\n      return isPromise\n        ? result.then((data: any) => classTransformer.plainToInstance(classType, data, params))\n        : classTransformer.plainToInstance(classType, result, params);\n    };\n  };\n}\n", "import { defaultMetadataStorage } from '../storage';\nimport { TransformFnParams, TransformOptions } from '../interfaces';\n\n/**\n * Defines a custom logic for value transformation.\n *\n * Can be applied to properties only.\n */\nexport function Transform(\n  transformFn: (params: TransformFnParams) => any,\n  options: TransformOptions = {}\n): PropertyDecorator {\n  return function (target: any, propertyName: string | Symbol): void {\n    defaultMetadataStorage.addTransformMetadata({\n      target: target.constructor,\n      propertyName: propertyName as string,\n      transformFn,\n      options,\n    });\n  };\n}\n", "import { defaultMetadataStorage } from '../storage';\nimport { TypeHelpOptions, TypeOptions } from '../interfaces';\n\n/**\n * Specifies a type of the property.\n * The given TypeFunction can return a constructor. A discriminator can be given in the options.\n *\n * Can be applied to properties only.\n */\nexport function Type(\n  typeFunction?: (type?: TypeHelpOptions) => Function,\n  options: TypeOptions = {}\n): PropertyDecorator {\n  return function (target: any, propertyName: string | Symbol): void {\n    const reflectedType = (Reflect as any).getMetadata('design:type', target, propertyName);\n    defaultMetadataStorage.addTypeMetadata({\n      target: target.constructor,\n      propertyName: propertyName as string,\n      reflectedType,\n      typeFunction,\n      options,\n    });\n  };\n}\n", "import { ClassTransformer } from './ClassTransformer';\nimport { ClassTransformOptions } from './interfaces';\nimport { ClassConstructor } from './interfaces';\n\nexport { ClassTransformer } from './ClassTransformer';\nexport * from './decorators';\nexport * from './interfaces';\nexport * from './enums';\n\nconst classTransformer = new ClassTransformer();\n\n/**\n * Converts class (constructor) object to plain (literal) object. Also works with arrays.\n *\n * @deprecated Function name changed, use the `instanceToPlain` method instead.\n */\nexport function classToPlain<T>(object: T, options?: ClassTransformOptions): Record<string, any>;\nexport function classToPlain<T>(object: T[], options?: ClassTransformOptions): Record<string, any>[];\nexport function classToPlain<T>(\n  object: T | T[],\n  options?: ClassTransformOptions\n): Record<string, any> | Record<string, any>[] {\n  return classTransformer.instanceToPlain(object, options);\n}\n\n/**\n * Converts class (constructor) object to plain (literal) object. Also works with arrays.\n */\nexport function instanceToPlain<T>(object: T, options?: ClassTransformOptions): Record<string, any>;\nexport function instanceToPlain<T>(object: T[], options?: ClassTransformOptions): Record<string, any>[];\nexport function instanceToPlain<T>(\n  object: T | T[],\n  options?: ClassTransformOptions\n): Record<string, any> | Record<string, any>[] {\n  return classTransformer.instanceToPlain(object, options);\n}\n\n/**\n * Converts class (constructor) object to plain (literal) object.\n * Uses given plain object as source object (it means fills given plain object with data from class object).\n * Also works with arrays.\n *\n * @deprecated This function is being removed.\n */\nexport function classToPlainFromExist<T>(\n  object: T,\n  plainObject: Record<string, any>,\n  options?: ClassTransformOptions\n): Record<string, any>;\nexport function classToPlainFromExist<T>(\n  object: T,\n  plainObjects: Record<string, any>[],\n  options?: ClassTransformOptions\n): Record<string, any>[];\nexport function classToPlainFromExist<T>(\n  object: T,\n  plainObject: Record<string, any> | Record<string, any>[],\n  options?: ClassTransformOptions\n): Record<string, any> | Record<string, any>[] {\n  return classTransformer.classToPlainFromExist(object, plainObject, options);\n}\n\n/**\n * Converts plain (literal) object to class (constructor) object. Also works with arrays.\n *\n * @deprecated Function name changed, use the `plainToInstance` method instead.\n */\nexport function plainToClass<T, V>(cls: ClassConstructor<T>, plain: V[], options?: ClassTransformOptions): T[];\nexport function plainToClass<T, V>(cls: ClassConstructor<T>, plain: V, options?: ClassTransformOptions): T;\nexport function plainToClass<T, V>(cls: ClassConstructor<T>, plain: V | V[], options?: ClassTransformOptions): T | T[] {\n  return classTransformer.plainToInstance(cls, plain as any, options);\n}\n\n/**\n * Converts plain (literal) object to class (constructor) object. Also works with arrays.\n */\nexport function plainToInstance<T, V>(cls: ClassConstructor<T>, plain: V[], options?: ClassTransformOptions): T[];\nexport function plainToInstance<T, V>(cls: ClassConstructor<T>, plain: V, options?: ClassTransformOptions): T;\nexport function plainToInstance<T, V>(\n  cls: ClassConstructor<T>,\n  plain: V | V[],\n  options?: ClassTransformOptions\n): T | T[] {\n  return classTransformer.plainToInstance(cls, plain as any, options);\n}\n\n/**\n * Converts plain (literal) object to class (constructor) object.\n * Uses given object as source object (it means fills given object with data from plain object).\n *  Also works with arrays.\n *\n * @deprecated This function is being removed. The current implementation is incorrect as it modifies the source object.\n */\nexport function plainToClassFromExist<T, V>(clsObject: T[], plain: V[], options?: ClassTransformOptions): T[];\nexport function plainToClassFromExist<T, V>(clsObject: T, plain: V, options?: ClassTransformOptions): T;\nexport function plainToClassFromExist<T, V>(clsObject: T, plain: V | V[], options?: ClassTransformOptions): T | T[] {\n  return classTransformer.plainToClassFromExist(clsObject, plain, options);\n}\n\n/**\n * Converts class (constructor) object to new class (constructor) object. Also works with arrays.\n */\nexport function instanceToInstance<T>(object: T, options?: ClassTransformOptions): T;\nexport function instanceToInstance<T>(object: T[], options?: ClassTransformOptions): T[];\nexport function instanceToInstance<T>(object: T | T[], options?: ClassTransformOptions): T | T[] {\n  return classTransformer.instanceToInstance(object, options);\n}\n\n/**\n * Converts class (constructor) object to plain (literal) object.\n * Uses given plain object as source object (it means fills given plain object with data from class object).\n * Also works with arrays.\n *\n * @deprecated This function is being removed. The current implementation is incorrect as it modifies the source object.\n */\nexport function classToClassFromExist<T>(object: T, fromObject: T, options?: ClassTransformOptions): T;\nexport function classToClassFromExist<T>(object: T, fromObjects: T[], options?: ClassTransformOptions): T[];\nexport function classToClassFromExist<T>(object: T, fromObject: T | T[], options?: ClassTransformOptions): T | T[] {\n  return classTransformer.classToClassFromExist(object, fromObject, options);\n}\n\n/**\n * Serializes given object to a JSON string.\n *\n * @deprecated This function is being removed. Please use\n * ```\n * JSON.stringify(instanceToPlain(object, options))\n * ```\n */\nexport function serialize<T>(object: T, options?: ClassTransformOptions): string;\nexport function serialize<T>(object: T[], options?: ClassTransformOptions): string;\nexport function serialize<T>(object: T | T[], options?: ClassTransformOptions): string {\n  return classTransformer.serialize(object, options);\n}\n\n/**\n * Deserializes given JSON string to a object of the given class.\n *\n * @deprecated This function is being removed. Please use the following instead:\n * ```\n * instanceToClass(cls, JSON.parse(json), options)\n * ```\n */\nexport function deserialize<T>(cls: ClassConstructor<T>, json: string, options?: ClassTransformOptions): T {\n  return classTransformer.deserialize(cls, json, options);\n}\n\n/**\n * Deserializes given JSON string to an array of objects of the given class.\n *\n * @deprecated This function is being removed. Please use the following instead:\n * ```\n * JSON.parse(json).map(value => instanceToClass(cls, value, options))\n * ```\n *\n */\nexport function deserializeArray<T>(cls: ClassConstructor<T>, json: string, options?: ClassTransformOptions): T[] {\n  return classTransformer.deserializeArray(cls, json, options);\n}\n"],
  "mappings": ";;;AAAA,IAAY;CAAZ,SAAYA,qBAAkB;AAC5B,EAAAA,oBAAAA,oBAAA,gBAAA,IAAA,CAAA,IAAA;AACA,EAAAA,oBAAAA,oBAAA,gBAAA,IAAA,CAAA,IAAA;AACA,EAAAA,oBAAAA,oBAAA,gBAAA,IAAA,CAAA,IAAA;AACF,GAJY,uBAAA,qBAAkB,CAAA,EAAA;;;ACM9B,IAAA;;EAAA,WAAA;AAAA,aAAAC,mBAAA;AAKU,WAAA,iBAAiB,oBAAI,IAAG;AACxB,WAAA,sBAAsB,oBAAI,IAAG;AAC7B,WAAA,mBAAmB,oBAAI,IAAG;AAC1B,WAAA,oBAAoB,oBAAI,IAAG;AAC3B,WAAA,gBAAgB,oBAAI,IAAG;IA8OjC;AAxOE,IAAAA,iBAAA,UAAA,kBAAA,SAAgB,UAAsB;AACpC,UAAI,CAAC,KAAK,eAAe,IAAI,SAAS,MAAM,GAAG;AAC7C,aAAK,eAAe,IAAI,SAAS,QAAQ,oBAAI,IAAG,CAAwB;;AAE1E,WAAK,eAAe,IAAI,SAAS,MAAM,EAAE,IAAI,SAAS,cAAc,QAAQ;IAC9E;AAEA,IAAAA,iBAAA,UAAA,uBAAA,SAAqB,UAA2B;AAC9C,UAAI,CAAC,KAAK,oBAAoB,IAAI,SAAS,MAAM,GAAG;AAClD,aAAK,oBAAoB,IAAI,SAAS,QAAQ,oBAAI,IAAG,CAA+B;;AAEtF,UAAI,CAAC,KAAK,oBAAoB,IAAI,SAAS,MAAM,EAAE,IAAI,SAAS,YAAY,GAAG;AAC7E,aAAK,oBAAoB,IAAI,SAAS,MAAM,EAAE,IAAI,SAAS,cAAc,CAAA,CAAE;;AAE7E,WAAK,oBAAoB,IAAI,SAAS,MAAM,EAAE,IAAI,SAAS,YAAY,EAAE,KAAK,QAAQ;IACxF;AAEA,IAAAA,iBAAA,UAAA,oBAAA,SAAkB,UAAwB;AACxC,UAAI,CAAC,KAAK,iBAAiB,IAAI,SAAS,MAAM,GAAG;AAC/C,aAAK,iBAAiB,IAAI,SAAS,QAAQ,oBAAI,IAAG,CAA0B;;AAE9E,WAAK,iBAAiB,IAAI,SAAS,MAAM,EAAE,IAAI,SAAS,cAAc,QAAQ;IAChF;AAEA,IAAAA,iBAAA,UAAA,qBAAA,SAAmB,UAAyB;AAC1C,UAAI,CAAC,KAAK,kBAAkB,IAAI,SAAS,MAAM,GAAG;AAChD,aAAK,kBAAkB,IAAI,SAAS,QAAQ,oBAAI,IAAG,CAA2B;;AAEhF,WAAK,kBAAkB,IAAI,SAAS,MAAM,EAAE,IAAI,SAAS,cAAc,QAAQ;IACjF;AAMA,IAAAA,iBAAA,UAAA,yBAAA,SACE,QACA,cACA,oBAAsC;AAEtC,aAAO,KAAK,cAAc,KAAK,qBAAqB,QAAQ,YAAY,EAAE,OAAO,SAAA,UAAQ;AACvF,YAAI,CAAC,SAAS;AAAS,iBAAO;AAC9B,YAAI,SAAS,QAAQ,gBAAgB,QAAQ,SAAS,QAAQ,gBAAgB;AAAM,iBAAO;AAE3F,YAAI,SAAS,QAAQ,gBAAgB,MAAM;AACzC,iBACE,uBAAuB,mBAAmB,kBAC1C,uBAAuB,mBAAmB;;AAG9C,YAAI,SAAS,QAAQ,gBAAgB,MAAM;AACzC,iBAAO,uBAAuB,mBAAmB;;AAGnD,eAAO;MACT,CAAC;IACH;AAEA,IAAAA,iBAAA,UAAA,sBAAA,SAAoB,QAAkB,cAAoB;AACxD,aAAO,KAAK,aAAa,KAAK,mBAAmB,QAAQ,YAAY;IACvE;AAEA,IAAAA,iBAAA,UAAA,qBAAA,SAAmB,QAAkB,cAAoB;AACvD,aAAO,KAAK,aAAa,KAAK,kBAAkB,QAAQ,YAAY;IACtE;AAEA,IAAAA,iBAAA,UAAA,iCAAA,SAA+B,QAAkB,MAAY;AAC3D,aAAO,KAAK,oBAAoB,MAAM,EAAE,KAAK,SAAA,UAAQ;AACnD,eAAO,SAAS,WAAW,SAAS,QAAQ,SAAS;MACvD,CAAC;IACH;AAEA,IAAAA,iBAAA,UAAA,mBAAA,SAAiB,QAAkB,cAAoB;AACrD,aAAO,KAAK,aAAa,KAAK,gBAAgB,QAAQ,YAAY;IACpE;AAEA,IAAAA,iBAAA,UAAA,cAAA,SAAY,QAAgB;AAC1B,UAAM,aAAa,KAAK,kBAAkB,IAAI,MAAM;AACpD,UAAM,UAAU,cAAc,WAAW,IAAI,MAAS;AACtD,UAAM,YAAY,KAAK,iBAAiB,IAAI,MAAM;AAClD,UAAM,SAAS,aAAa,UAAU,IAAI,MAAS;AACnD,UAAK,WAAW,UAAY,CAAC,WAAW,CAAC;AAAS,eAAO;AACzD,aAAO,UAAU,eAAe;IAClC;AAEA,IAAAA,iBAAA,UAAA,sBAAA,SAAoB,QAAgB;AAClC,aAAO,KAAK,YAAY,KAAK,kBAAkB,MAAM;IACvD;AAEA,IAAAA,iBAAA,UAAA,uBAAA,SAAqB,QAAgB;AACnC,aAAO,KAAK,YAAY,KAAK,mBAAmB,MAAM;IACxD;AAEA,IAAAA,iBAAA,UAAA,uBAAA,SAAqB,QAAkB,oBAAsC;AAC3E,aAAO,KAAK,oBAAoB,MAAM,EACnC,OAAO,SAAA,UAAQ;AACd,YAAI,CAAC,SAAS;AAAS,iBAAO;AAC9B,YAAI,SAAS,QAAQ,gBAAgB,QAAQ,SAAS,QAAQ,gBAAgB;AAAM,iBAAO;AAE3F,YAAI,SAAS,QAAQ,gBAAgB,MAAM;AACzC,iBACE,uBAAuB,mBAAmB,kBAC1C,uBAAuB,mBAAmB;;AAG9C,YAAI,SAAS,QAAQ,gBAAgB,MAAM;AACzC,iBAAO,uBAAuB,mBAAmB;;AAGnD,eAAO;MACT,CAAC,EACA,IAAI,SAAA,UAAQ;AAAI,eAAA,SAAS;MAAT,CAAqB;IAC1C;AAEA,IAAAA,iBAAA,UAAA,wBAAA,SAAsB,QAAkB,oBAAsC;AAC5E,aAAO,KAAK,qBAAqB,MAAM,EACpC,OAAO,SAAA,UAAQ;AACd,YAAI,CAAC,SAAS;AAAS,iBAAO;AAC9B,YAAI,SAAS,QAAQ,gBAAgB,QAAQ,SAAS,QAAQ,gBAAgB;AAAM,iBAAO;AAE3F,YAAI,SAAS,QAAQ,gBAAgB,MAAM;AACzC,iBACE,uBAAuB,mBAAmB,kBAC1C,uBAAuB,mBAAmB;;AAG9C,YAAI,SAAS,QAAQ,gBAAgB,MAAM;AACzC,iBAAO,uBAAuB,mBAAmB;;AAGnD,eAAO;MACT,CAAC,EACA,IAAI,SAAA,UAAQ;AAAI,eAAA,SAAS;MAAT,CAAqB;IAC1C;AAEA,IAAAA,iBAAA,UAAA,QAAA,WAAA;AACE,WAAK,eAAe,MAAK;AACzB,WAAK,iBAAiB,MAAK;AAC3B,WAAK,kBAAkB,MAAK;AAC5B,WAAK,cAAc,MAAK;IAC1B;AAMQ,IAAAA,iBAAA,UAAA,cAAR,SACE,WACA,QAAgB;AAEhB,UAAM,wBAAwB,UAAU,IAAI,MAAM;AAClD,UAAI;AACJ,UAAI,uBAAuB;AACzB,6BAAqB,MAAM,KAAK,sBAAsB,OAAM,CAAE,EAAE,OAAO,SAAA,MAAI;AAAI,iBAAA,KAAK,iBAAiB;QAAtB,CAA+B;;AAEhH,UAAM,wBAA6B,CAAA;AACnC,eAAuB,KAAA,GAAA,KAAA,KAAK,aAAa,MAAM,GAAxB,KAAA,GAAA,QAAA,MAA2B;AAA7C,YAAM,WAAQ,GAAA,EAAA;AACjB,YAAM,sBAAsB,UAAU,IAAI,QAAQ;AAClD,YAAI,qBAAqB;AACvB,cAAM,uBAAuB,MAAM,KAAK,oBAAoB,OAAM,CAAE,EAAE,OACpE,SAAA,MAAI;AAAI,mBAAA,KAAK,iBAAiB;UAAtB,CAA+B;AAEzC,gCAAsB,KAAI,MAA1B,uBAA8B,oBAAoB;;;AAGtD,aAAO,sBAAsB,OAAO,sBAAsB,CAAA,CAAE;IAC9D;AAEQ,IAAAA,iBAAA,UAAA,eAAR,SACE,WACA,QACA,cAAoB;AAEpB,UAAM,wBAAwB,UAAU,IAAI,MAAM;AAClD,UAAI,uBAAuB;AACzB,YAAM,qBAAqB,sBAAsB,IAAI,YAAY;AACjE,YAAI,oBAAoB;AACtB,iBAAO;;;AAGX,eAAuB,KAAA,GAAA,KAAA,KAAK,aAAa,MAAM,GAAxB,KAAA,GAAA,QAAA,MAA2B;AAA7C,YAAM,WAAQ,GAAA,EAAA;AACjB,YAAM,sBAAsB,UAAU,IAAI,QAAQ;AAClD,YAAI,qBAAqB;AACvB,cAAM,iBAAiB,oBAAoB,IAAI,YAAY;AAC3D,cAAI,gBAAgB;AAClB,mBAAO;;;;AAIb,aAAO;IACT;AAEQ,IAAAA,iBAAA,UAAA,gBAAR,SACE,WACA,QACA,cAAoB;AAEpB,UAAM,wBAAwB,UAAU,IAAI,MAAM;AAClD,UAAI;AACJ,UAAI,uBAAuB;AACzB,6BAAqB,sBAAsB,IAAI,YAAY;;AAE7D,UAAM,8BAAmC,CAAA;AACzC,eAAuB,KAAA,GAAA,KAAA,KAAK,aAAa,MAAM,GAAxB,KAAA,GAAA,QAAA,MAA2B;AAA7C,YAAM,WAAQ,GAAA,EAAA;AACjB,YAAM,sBAAsB,UAAU,IAAI,QAAQ;AAClD,YAAI,qBAAqB;AACvB,cAAI,oBAAoB,IAAI,YAAY,GAAG;AACzC,wCAA4B,KAAI,MAAhC,6BAAoC,oBAAoB,IAAI,YAAY,CAAC;;;;AAI/E,aAAO,4BACJ,MAAK,EACL,QAAO,EACP,QAAQ,sBAAsB,CAAA,GAAI,MAAK,EAAG,QAAO,CAAE;IACxD;AAEQ,IAAAA,iBAAA,UAAA,eAAR,SAAqB,QAAgB;AACnC,UAAI,CAAC;AAAQ,eAAO,CAAA;AACpB,UAAI,CAAC,KAAK,cAAc,IAAI,MAAM,GAAG;AACnC,YAAM,YAAwB,CAAA;AAC9B,iBACM,YAAY,OAAO,eAAe,OAAO,UAAU,WAAW,GAClE,OAAO,UAAU,cAAc,aAC/B,YAAY,OAAO,eAAe,UAAU,UAAU,WAAW,GACjE;AACA,oBAAU,KAAK,SAAS;;AAE1B,aAAK,cAAc,IAAI,QAAQ,SAAS;;AAE1C,aAAO,KAAK,cAAc,IAAI,MAAM;IACtC;AACF,WAAAA;EAAA,EAvPA;;;;ACDO,IAAM,yBAAyB,IAAI,gBAAe;;;ACCnD,SAAU,YAAS;AACvB,MAAI,OAAO,eAAe,aAAa;AACrC,WAAO;;AAGT,MAAI,OAAO,WAAW,aAAa;AACjC,WAAO;;AAKT,MAAI,OAAO,WAAW,aAAa;AAGjC,WAAO;;AAKT,MAAI,OAAO,SAAS,aAAa;AAG/B,WAAO;;AAEX;;;AC9BM,SAAU,UAAa,GAAM;AACjC,SAAO,MAAM,QAAQ,OAAO,MAAM,YAAY,OAAO,EAAE,SAAS;AAClE;;;;;;;;;;;;;;ACGA,SAAS,qBAAqB,WAAmB;AAC/C,MAAM,QAAQ,IAAK,UAAiB;AACpC,MAAI,EAAE,iBAAiB,QAAQ,EAAE,UAAU,QAAQ;AACjD,WAAO,CAAA;;AAET,SAAO;AACT;AAEA,IAAA;;EAAA,WAAA;AAWE,aAAAC,4BAAoB,oBAAgD,SAA8B;AAA9E,WAAA,qBAAA;AAAgD,WAAA,UAAA;AAN5D,WAAA,iBAAiB,oBAAI,IAAG;IAMqE;AAMrG,IAAAA,4BAAA,UAAA,YAAA,SACE,QACA,OACA,YACA,WACA,OACA,OAAiB;AANnB,UAAA,QAAA;AAME,UAAA,UAAA,QAAA;AAAA,gBAAA;MAAiB;AAEjB,UAAI,MAAM,QAAQ,KAAK,KAAK,iBAAiB,KAAK;AAChD,YAAM,aACJ,aAAa,KAAK,uBAAuB,mBAAmB,iBACxD,qBAAqB,SAAS,IAC9B,CAAA;AACL,cAAgB,QAAQ,SAAC,UAAU,OAAK;AACvC,cAAM,YAAY,SAAS,OAAO,KAAK,IAAI;AAC3C,cAAI,CAAC,MAAK,QAAQ,uBAAuB,CAAC,MAAK,WAAW,QAAQ,GAAG;AACnE,gBAAI,iBAAc;AAClB,gBACE,OAAO,eAAe,cACtB,cACA,WAAW,WACX,WAAW,QAAQ,iBACnB,WAAW,QAAQ,cAAc,YACjC,WAAW,QAAQ,cAAc,UACjC;AACA,kBAAI,MAAK,uBAAuB,mBAAmB,gBAAgB;AACjE,iCAAiB,WAAW,QAAQ,cAAc,SAAS,KACzD,SAAA,SAAO;AACL,yBAAA,QAAQ,SAAS,SAAU,WAAwC,QAAQ,cAAc,QAAQ;gBAAjG,CAAkG;AAEtG,oBAAM,UAA2B,EAAE,WAAW,YAAU,QAAQ,UAAU,UAAU,OAAS;AAC7F,oBAAM,UAAU,WAAW,aAAa,OAAO;AAC/C,mCAAmB,SAAa,iBAAiB,UAAY,iBAAiB,eAAe;AAC7F,oBAAI,CAAC,WAAW,QAAQ;AACtB,yBAAO,SAAS,WAAW,QAAQ,cAAc,QAAQ;;AAG7D,kBAAI,MAAK,uBAAuB,mBAAmB,gBAAgB;AACjE,iCAAiB,SAAS;;AAE5B,kBAAI,MAAK,uBAAuB,mBAAmB,gBAAgB;AACjE,yBAAS,WAAW,QAAQ,cAAc,QAAQ,IAAI,WAAW,QAAQ,cAAc,SAAS,KAC9F,SAAA,SAAO;AAAI,yBAAA,QAAQ,UAAU,SAAS;gBAA3B,CAAsC,EACjD;;mBAEC;AACL,+BAAiB;;AAEnB,gBAAM,UAAQ,MAAK,UACjB,WACA,UACA,gBACA,QACA,oBAAoB,KACpB,QAAQ,CAAC;AAGX,gBAAI,sBAAoB,KAAK;AAC3B,yBAAS,IAAI,OAAK;mBACb;AACL,yBAAS,KAAK,OAAK;;qBAEZ,MAAK,uBAAuB,mBAAmB,gBAAgB;AACxE,gBAAI,sBAAoB,KAAK;AAC3B,yBAAS,IAAI,QAAQ;mBAChB;AACL,yBAAS,KAAK,QAAQ;;;QAG5B,CAAC;AACD,eAAO;iBACE,eAAe,UAAU,CAAC,OAAO;AAC1C,YAAI,UAAU,QAAQ,UAAU;AAAW,iBAAO;AAClD,eAAO,OAAO,KAAK;iBACV,eAAe,UAAU,CAAC,OAAO;AAC1C,YAAI,UAAU,QAAQ,UAAU;AAAW,iBAAO;AAClD,eAAO,OAAO,KAAK;iBACV,eAAe,WAAW,CAAC,OAAO;AAC3C,YAAI,UAAU,QAAQ,UAAU;AAAW,iBAAO;AAClD,eAAO,QAAQ,KAAK;kBACV,eAAe,QAAQ,iBAAiB,SAAS,CAAC,OAAO;AACnE,YAAI,iBAAiB,MAAM;AACzB,iBAAO,IAAI,KAAK,MAAM,QAAO,CAAE;;AAEjC,YAAI,UAAU,QAAQ,UAAU;AAAW,iBAAO;AAClD,eAAO,IAAI,KAAK,KAAK;iBACZ,CAAC,CAAC,UAAS,EAAG,WAAW,eAAe,UAAU,iBAAiB,WAAW,CAAC,OAAO;AAC/F,YAAI,UAAU,QAAQ,UAAU;AAAW,iBAAO;AAClD,eAAO,OAAO,KAAK,KAAK;iBACf,UAAU,KAAK,KAAK,CAAC,OAAO;AACrC,eAAO,IAAI,QAAQ,SAAC,SAAS,QAAM;AACjC,gBAAM,KACJ,SAAC,MAAS;AAAK,mBAAA,QAAQ,MAAK,UAAU,QAAW,MAAM,YAAY,QAAW,QAAW,QAAQ,CAAC,CAAC;UAApF,GACf,MAAM;QAEV,CAAC;iBACQ,CAAC,SAAS,UAAU,QAAQ,OAAO,UAAU,YAAY,OAAO,MAAM,SAAS,YAAY;AAGpG,eAAO;iBACE,OAAO,UAAU,YAAY,UAAU,MAAM;AAEtD,YAAI,CAAC,cAAc,MAAM,gBAAgB;AACvC,cAAI,CAAC,MAAM,QAAQ,KAAK,KAAK,MAAM,gBAAgB,OAAO;iBAKnD;AAEL,yBAAa,MAAM;;AAEvB,YAAI,CAAC,cAAc;AAAQ,uBAAa,OAAO;AAE/C,YAAI,KAAK,QAAQ,qBAAqB;AAEpC,eAAK,eAAe,IAAI,KAAK;;AAG/B,YAAM,OAAO,KAAK,QAAQ,YAAwB,OAAO,KAAK;AAC9D,YAAI,WAAgB,SAAS,SAAS,CAAA;AACtC,YACE,CAAC,WACA,KAAK,uBAAuB,mBAAmB,kBAC9C,KAAK,uBAAuB,mBAAmB,iBACjD;AACA,cAAI,OAAO;AACT,uBAAW,oBAAI,IAAG;qBACT,YAAY;AACrB,uBAAW,IAAK,WAAkB;iBAC7B;AACL,uBAAW,CAAA;;;+BAKJC,MAAG;AACZ,cAAIA,SAAQ,eAAeA,SAAQ,eAAe;;;AAIlD,cAAM,WAAWA;AACjB,cAAI,cAAcA,MAChB,eAAeA;AACjB,cAAI,CAAC,OAAK,QAAQ,oBAAoB,YAAY;AAChD,gBAAI,OAAK,uBAAuB,mBAAmB,gBAAgB;AACjE,kBAAM,iBAAiB,uBAAuB,+BAA+B,YAAwBA,IAAG;AACxG,kBAAI,gBAAgB;AAClB,+BAAe,eAAe;AAC9B,8BAAc,eAAe;;uBAG/B,OAAK,uBAAuB,mBAAmB,kBAC/C,OAAK,uBAAuB,mBAAmB,gBAC/C;AACA,kBAAM,iBAAiB,uBAAuB,mBAAmB,YAAwBA,IAAG;AAC5F,kBAAI,kBAAkB,eAAe,WAAW,eAAe,QAAQ,MAAM;AAC3E,8BAAc,eAAe,QAAQ;;;;AAM3C,cAAI,WAAgB;AACpB,cAAI,OAAK,uBAAuB,mBAAmB,gBAAgB;AAOjE,uBAAW,MAAM,QAAQ;iBACpB;AACL,gBAAI,iBAAiB,KAAK;AACxB,yBAAW,MAAM,IAAI,QAAQ;uBACpB,MAAM,QAAQ,aAAa,UAAU;AAC9C,yBAAW,MAAM,QAAQ,EAAC;mBACrB;AACL,yBAAW,MAAM,QAAQ;;;AAK7B,cAAI,OAAY,QACd,gBAAgB,oBAAoB;AACtC,cAAI,cAAc,OAAO;AACvB,mBAAO;qBACE,YAAY;AACrB,gBAAM,aAAW,uBAAuB,iBAAiB,YAAwB,YAAY;AAC7F,gBAAI,YAAU;AACZ,kBAAM,UAA2B,EAAE,WAAW,UAAU,QAAQ,OAAO,UAAU,aAAY;AAC7F,kBAAM,UAAU,WAAS,eAAe,WAAS,aAAa,OAAO,IAAI,WAAS;AAClF,kBACE,WAAS,WACT,WAAS,QAAQ,iBACjB,WAAS,QAAQ,cAAc,YAC/B,WAAS,QAAQ,cAAc,UAC/B;AACA,oBAAI,EAAE,MAAM,QAAQ,aAAa,QAAQ;AACvC,sBAAI,OAAK,uBAAuB,mBAAmB,gBAAgB;AACjE,2BAAO,WAAS,QAAQ,cAAc,SAAS,KAAK,SAAA,SAAO;AACzD,0BAAI,YAAY,oBAAoB,UAAU,WAAS,QAAQ,cAAc,YAAY,UAAU;AACjG,+BAAO,QAAQ,SAAS,SAAS,WAAS,QAAQ,cAAc,QAAQ;;oBAE5E,CAAC;AACD,6BAAS,SAAa,OAAO,UAAY,OAAO,KAAK;AACrD,wBAAI,CAAC,WAAS,QAAQ,2BAA2B;AAC/C,0BAAI,YAAY,oBAAoB,UAAU,WAAS,QAAQ,cAAc,YAAY,UAAU;AACjG,+BAAO,SAAS,WAAS,QAAQ,cAAc,QAAQ;;;;AAI7D,sBAAI,OAAK,uBAAuB,mBAAmB,gBAAgB;AACjE,2BAAO,SAAS;;AAElB,sBAAI,OAAK,uBAAuB,mBAAmB,gBAAgB;AACjE,wBAAI,UAAU;AACZ,+BAAS,WAAS,QAAQ,cAAc,QAAQ,IAAI,WAAS,QAAQ,cAAc,SAAS,KAC1F,SAAA,SAAO;AAAI,+BAAA,QAAQ,UAAU,SAAS;sBAA3B,CAAsC,EACjD;;;uBAGD;AACL,yBAAO;;qBAEJ;AACL,uBAAO;;AAET,8BAAgB,iBAAiB,WAAS,kBAAkB;uBACnD,OAAK,QAAQ,YAAY;AAElC,qBAAK,QAAQ,WACV,OAAO,SAAA,KAAG;AAAI,uBAAA,IAAI,WAAW,cAAc,CAAC,CAAC,IAAI,WAAW,YAAY;cAA1D,CAA2D,EACzE,QAAQ,SAAA,KAAG;AAAI,uBAAC,OAAO,IAAI,WAAW,YAAY;cAAnC,CAAqC;uBAEvD,OAAK,QAAQ,4BACb,OAAK,uBAAuB,mBAAmB,gBAC/C;AAGA,kBAAM,gBAAiB,QAAgB,YACrC,eACC,WAAwB,WACzB,YAAY;AAGd,kBAAI,eAAe;AACjB,uBAAO;;;;AAMb,cAAM,cAAY,MAAM,QAAQ,MAAM,QAAQ,CAAC,IAC3C,OAAK,iBAAiB,YAAwB,YAAY,IAC1D;AAGJ,cAAM,YAAY,SAAS,OAAO,QAAQ,IAAI;AAQ9C,cAAI,SAAS,YAAY,WAAW;AAClC,gBAAM,aAAa,OAAO,yBAAyB,SAAS,YAAY,WAAW,WAAW;AAC9F,iBACG,OAAK,uBAAuB,mBAAmB,kBAC9C,OAAK,uBAAuB,mBAAmB;aAE/C,cAAc,CAAC,WAAW,OAAQ,SAAS,WAAW,aAAa;;;AAMzE,cAAI,CAAC,OAAK,QAAQ,uBAAuB,CAAC,OAAK,WAAW,QAAQ,GAAG;AACnE,gBAAM,eAAe,OAAK,uBAAuB,mBAAmB,iBAAiB,cAAcA;AACnG,gBAAI,aAAU;AAEd,gBAAI,OAAK,uBAAuB,mBAAmB,gBAAgB;AAEjE,2BAAa,MAAM,YAAY;AAE/B,2BAAa,OAAK,2BAChB,YACA,YACA,cACA,OACA,OAAK,kBAAkB;AAGzB,2BAAa,MAAM,YAAY,MAAM,aAAa,WAAW;AAE7D,2BAAa,OAAK,UAAU,WAAW,YAAY,MAAM,aAAW,eAAe,QAAQ,CAAC;mBACvF;AACL,kBAAI,aAAa,UAAa,OAAK,QAAQ,qBAAqB;AAE9D,6BAAa,SAAS,WAAW;qBAC5B;AACL,6BAAa,OAAK,UAAU,WAAW,UAAU,MAAM,aAAW,eAAe,QAAQ,CAAC;AAC1F,6BAAa,OAAK,2BAChB,YACA,YACA,cACA,OACA,OAAK,kBAAkB;;;AAK7B,gBAAI,eAAe,UAAa,OAAK,QAAQ,mBAAmB;AAC9D,kBAAI,oBAAoB,KAAK;AAC3B,yBAAS,IAAI,aAAa,UAAU;qBAC/B;AACL,yBAAS,WAAW,IAAI;;;qBAGnB,OAAK,uBAAuB,mBAAmB,gBAAgB;AACxE,gBAAI,aAAa;AACjB,yBAAa,OAAK,2BAChB,YACA,YACAA,MACA,OACA,OAAK,kBAAkB;AAEzB,gBAAI,eAAe,UAAa,OAAK,QAAQ,mBAAmB;AAC9D,kBAAI,oBAAoB,KAAK;AAC3B,yBAAS,IAAI,aAAa,UAAU;qBAC/B;AACL,yBAAS,WAAW,IAAI;;;;;;AArMhC,iBAAkB,KAAA,GAAA,SAAA,MAAA,KAAA,OAAA,QAAA,MAAI;AAAjB,cAAM,MAAG,OAAA,EAAA;kBAAH,GAAG;;AA2Md,YAAI,KAAK,QAAQ,qBAAqB;AACpC,eAAK,eAAe,OAAO,KAAK;;AAGlC,eAAO;aACF;AACL,eAAO;;IAEX;AAEQ,IAAAD,4BAAA,UAAA,6BAAR,SACE,OACA,QACA,KACA,KACA,oBAAsC;AALxC,UAAA,QAAA;AAOE,UAAI,YAAY,uBAAuB,uBAAuB,QAAQ,KAAK,KAAK,kBAAkB;AAGlG,UAAI,KAAK,QAAQ,YAAY,QAAW;AACtC,oBAAY,UAAU,OAAO,SAAA,UAAQ;AACnC,cAAI,CAAC,SAAS;AAAS,mBAAO;AAE9B,iBAAO,MAAK,aAAa,SAAS,QAAQ,OAAO,SAAS,QAAQ,KAAK;QACzE,CAAC;;AAIH,UAAI,KAAK,QAAQ,UAAU,KAAK,QAAQ,OAAO,QAAQ;AACrD,oBAAY,UAAU,OAAO,SAAA,UAAQ;AACnC,cAAI,CAAC,SAAS;AAAS,mBAAO;AAE9B,iBAAO,MAAK,YAAY,SAAS,QAAQ,MAAM;QACjD,CAAC;aACI;AACL,oBAAY,UAAU,OAAO,SAAA,UAAQ;AACnC,iBAAO,CAAC,SAAS,WAAW,CAAC,SAAS,QAAQ,UAAU,CAAC,SAAS,QAAQ,OAAO;QACnF,CAAC;;AAGH,gBAAU,QAAQ,SAAA,UAAQ;AACxB,gBAAQ,SAAS,YAAY,EAAE,OAAO,KAAK,KAAK,MAAM,oBAAoB,SAAS,MAAK,QAAO,CAAE;MACnG,CAAC;AAED,aAAO;IACT;AAGQ,IAAAA,4BAAA,UAAA,aAAR,SAAmB,QAA2B;AAC5C,aAAO,KAAK,eAAe,IAAI,MAAM;IACvC;AAEQ,IAAAA,4BAAA,UAAA,mBAAR,SAAyB,QAAkB,cAAoB;AAC7D,UAAI,CAAC;AAAQ,eAAO;AACpB,UAAM,OAAO,uBAAuB,iBAAiB,QAAQ,YAAY;AACzE,aAAO,OAAO,KAAK,gBAAgB;IACrC;AAEQ,IAAAA,4BAAA,UAAA,UAAR,SAAgB,QAAkB,QAA6B,OAAc;AAA7E,UAAA,QAAA;AAEE,UAAI,WAAW,uBAAuB,YAAY,MAAM;AACxD,UAAI,aAAa;AAAQ,mBAAW,KAAK,QAAQ,YAAY;AAG7D,UAAI,OAAc,CAAA;AAClB,UAAI,aAAa,eAAe,OAAO;AACrC,YAAI,kBAAkB,KAAK;AACzB,iBAAO,MAAM,KAAK,OAAO,KAAI,CAAE;eAC1B;AACL,iBAAO,OAAO,KAAK,MAAM;;;AAI7B,UAAI,OAAO;AAET,eAAO;;AAOT,UAAI,KAAK,QAAQ,oBAAoB,KAAK,QAAQ,2BAA2B,QAAQ;AACnF,YAAM,oBAAoB,uBAAuB,qBAAqB,QAAQ,KAAK,kBAAkB;AACrG,YAAM,qBAAqB,uBAAuB,sBAAsB,QAAQ,KAAK,kBAAkB;AACvG,eAAI,cAAA,cAAA,CAAA,GAAO,mBAAiB,IAAA,GAAK,oBAAkB,IAAA;;AAGrD,UAAI,CAAC,KAAK,QAAQ,oBAAoB,QAAQ;AAE5C,YAAI,oBAAoB,uBAAuB,qBAAqB,QAAQ,KAAK,kBAAkB;AACnG,YAAI,KAAK,uBAAuB,mBAAmB,gBAAgB;AACjE,8BAAoB,kBAAkB,IAAI,SAAA,KAAG;AAC3C,gBAAM,iBAAiB,uBAAuB,mBAAmB,QAAQ,GAAG;AAC5E,gBAAI,kBAAkB,eAAe,WAAW,eAAe,QAAQ,MAAM;AAC3E,qBAAO,eAAe,QAAQ;;AAGhC,mBAAO;UACT,CAAC;;AAEH,YAAI,KAAK,QAAQ,yBAAyB;AACxC,iBAAO;eACF;AACL,iBAAO,KAAK,OAAO,iBAAiB;;AAItC,YAAM,uBAAqB,uBAAuB,sBAAsB,QAAQ,KAAK,kBAAkB;AACvG,YAAI,qBAAmB,SAAS,GAAG;AACjC,iBAAO,KAAK,OAAO,SAAA,KAAG;AACpB,mBAAO,CAAC,qBAAmB,SAAS,GAAG;UACzC,CAAC;;AAIH,YAAI,KAAK,QAAQ,YAAY,QAAW;AACtC,iBAAO,KAAK,OAAO,SAAA,KAAG;AACpB,gBAAM,iBAAiB,uBAAuB,mBAAmB,QAAQ,GAAG;AAC5E,gBAAI,CAAC,kBAAkB,CAAC,eAAe;AAAS,qBAAO;AAEvD,mBAAO,MAAK,aAAa,eAAe,QAAQ,OAAO,eAAe,QAAQ,KAAK;UACrF,CAAC;;AAIH,YAAI,KAAK,QAAQ,UAAU,KAAK,QAAQ,OAAO,QAAQ;AACrD,iBAAO,KAAK,OAAO,SAAA,KAAG;AACpB,gBAAM,iBAAiB,uBAAuB,mBAAmB,QAAQ,GAAG;AAC5E,gBAAI,CAAC,kBAAkB,CAAC,eAAe;AAAS,qBAAO;AAEvD,mBAAO,MAAK,YAAY,eAAe,QAAQ,MAAM;UACvD,CAAC;eACI;AACL,iBAAO,KAAK,OAAO,SAAA,KAAG;AACpB,gBAAM,iBAAiB,uBAAuB,mBAAmB,QAAQ,GAAG;AAC5E,mBACE,CAAC,kBACD,CAAC,eAAe,WAChB,CAAC,eAAe,QAAQ,UACxB,CAAC,eAAe,QAAQ,OAAO;UAEnC,CAAC;;;AAKL,UAAI,KAAK,QAAQ,mBAAmB,KAAK,QAAQ,gBAAgB,QAAQ;AACvE,eAAO,KAAK,OAAO,SAAA,KAAG;AACpB,iBAAA,MAAK,QAAQ,gBAAgB,MAAM,SAAA,QAAM;AACvC,mBAAO,IAAI,OAAO,GAAG,OAAO,MAAM,MAAM;UAC1C,CAAC;QAFD,CAEE;;AAKN,aAAO,KAAK,OAAO,SAAC,KAAK,OAAOE,OAAI;AAClC,eAAOA,MAAK,QAAQ,GAAG,MAAM;MAC/B,CAAC;AAED,aAAO;IACT;AAEQ,IAAAF,4BAAA,UAAA,eAAR,SAAqB,OAAe,OAAa;AAC/C,UAAI,WAAW;AACf,UAAI,YAAY;AAAO,mBAAW,KAAK,QAAQ,WAAW;AAC1D,UAAI,YAAY;AAAO,mBAAW,KAAK,QAAQ,UAAU;AAEzD,aAAO;IACT;AAEQ,IAAAA,4BAAA,UAAA,cAAR,SAAoB,QAAgB;AAClC,UAAI,CAAC;AAAQ,eAAO;AAEpB,aAAO,KAAK,QAAQ,OAAO,KAAK,SAAA,aAAW;AAAI,eAAA,OAAO,SAAS,WAAW;MAA3B,CAA4B;IAC7E;AACF,WAAAA;EAAA,EArhBA;;;;ACRO,IAAM,iBAAiD;EAC5D,qBAAqB;EACrB,0BAA0B;EAC1B,yBAAyB;EACzB,iBAAiB;EACjB,qBAAqB;EACrB,mBAAmB;EACnB,QAAQ;EACR,kBAAkB;EAClB,UAAU;EACV,YAAY;EACZ,SAAS;;;;;;;;;;;;;;;;ACVX,IAAA;;EAAA,WAAA;AAAA,aAAAG,oBAAA;IAoJA;AA1IE,IAAAA,kBAAA,UAAA,kBAAA,SACE,QACA,SAA+B;AAE/B,UAAM,WAAW,IAAI,2BAA2B,mBAAmB,gBAAc,SAAA,SAAA,CAAA,GAC5E,cAAc,GACd,OAAO,CAAA;AAEZ,aAAO,SAAS,UAAU,QAAW,QAAQ,QAAW,QAAW,QAAW,MAAS;IACzF;AAiBA,IAAAA,kBAAA,UAAA,wBAAA,SACE,QACA,aACA,SAA+B;AAE/B,UAAM,WAAW,IAAI,2BAA2B,mBAAmB,gBAAc,SAAA,SAAA,CAAA,GAC5E,cAAc,GACd,OAAO,CAAA;AAEZ,aAAO,SAAS,UAAU,aAAa,QAAQ,QAAW,QAAW,QAAW,MAAS;IAC3F;AAeA,IAAAA,kBAAA,UAAA,kBAAA,SACE,KACA,OACA,SAA+B;AAE/B,UAAM,WAAW,IAAI,2BAA2B,mBAAmB,gBAAc,SAAA,SAAA,CAAA,GAC5E,cAAc,GACd,OAAO,CAAA;AAEZ,aAAO,SAAS,UAAU,QAAW,OAAO,KAAK,QAAW,QAAW,MAAS;IAClF;AAaA,IAAAA,kBAAA,UAAA,wBAAA,SACE,WACA,OACA,SAA+B;AAE/B,UAAM,WAAW,IAAI,2BAA2B,mBAAmB,gBAAc,SAAA,SAAA,CAAA,GAC5E,cAAc,GACd,OAAO,CAAA;AAEZ,aAAO,SAAS,UAAU,WAAW,OAAO,QAAW,QAAW,QAAW,MAAS;IACxF;AAOA,IAAAA,kBAAA,UAAA,qBAAA,SAAsB,QAAiB,SAA+B;AACpE,UAAM,WAAW,IAAI,2BAA2B,mBAAmB,gBAAc,SAAA,SAAA,CAAA,GAC5E,cAAc,GACd,OAAO,CAAA;AAEZ,aAAO,SAAS,UAAU,QAAW,QAAQ,QAAW,QAAW,QAAW,MAAS;IACzF;AASA,IAAAA,kBAAA,UAAA,wBAAA,SAAyB,QAAW,YAAqB,SAA+B;AACtF,UAAM,WAAW,IAAI,2BAA2B,mBAAmB,gBAAc,SAAA,SAAA,CAAA,GAC5E,cAAc,GACd,OAAO,CAAA;AAEZ,aAAO,SAAS,UAAU,YAAY,QAAQ,QAAW,QAAW,QAAW,MAAS;IAC1F;AAOA,IAAAA,kBAAA,UAAA,YAAA,SAAa,QAAiB,SAA+B;AAC3D,aAAO,KAAK,UAAU,KAAK,gBAAgB,QAAQ,OAAO,CAAC;IAC7D;AAKA,IAAAA,kBAAA,UAAA,cAAA,SAAe,KAA0B,MAAc,SAA+B;AACpF,UAAM,aAAgB,KAAK,MAAM,IAAI;AACrC,aAAO,KAAK,gBAAgB,KAAK,YAAY,OAAO;IACtD;AAKA,IAAAA,kBAAA,UAAA,mBAAA,SAAoB,KAA0B,MAAc,SAA+B;AACzF,UAAM,aAAoB,KAAK,MAAM,IAAI;AACzC,aAAO,KAAK,gBAAgB,KAAK,YAAY,OAAO;IACtD;AACF,WAAAA;EAAA,EApJA;;;;ACIM,SAAU,QAAQ,SAA4B;AAA5B,MAAA,YAAA,QAAA;AAAA,cAAA,CAAA;EAA4B;AAOlD,SAAO,SAAU,QAAa,cAA8B;AAC1D,2BAAuB,mBAAmB;MACxC,QAAQ,kBAAkB,WAAW,SAAS,OAAO;MACrD;MACA;KACD;EACH;AACF;;;ACdM,SAAU,OAAO,SAA2B;AAA3B,MAAA,YAAA,QAAA;AAAA,cAAA,CAAA;EAA2B;AAOhD,SAAO,SAAU,QAAa,cAA8B;AAC1D,2BAAuB,kBAAkB;MACvC,QAAQ,kBAAkB,WAAW,SAAS,OAAO;MACrD;MACA;KACD;EACH;AACF;;;AChBM,SAAU,4BAA4B,QAA8B;AACxE,SAAO,SAAU,QAA6B,aAA8B,YAA8B;AACxG,QAAMC,oBAAqC,IAAI,iBAAgB;AAC/D,QAAM,iBAAiB,WAAW;AAElC,eAAW,QAAQ,WAAA;AAAU,UAAA,OAAA,CAAA;eAAA,KAAA,GAAA,KAAA,UAAA,QAAA,MAAc;AAAd,aAAA,EAAA,IAAA,UAAA,EAAA;;AAC3B,UAAM,SAAc,eAAe,MAAM,MAAM,IAAI;AACnD,UAAMC,aACJ,CAAC,CAAC,WAAW,OAAO,WAAW,YAAY,OAAO,WAAW,eAAe,OAAO,OAAO,SAAS;AACrG,aAAOA,aACH,OAAO,KAAK,SAAC,MAAS;AAAK,eAAAD,kBAAiB,mBAAmB,MAAM,MAAM;MAAhD,CAAiD,IAC5EA,kBAAiB,mBAAmB,QAAQ,MAAM;IACxD;EACF;AACF;;;ACdM,SAAU,yBAAyB,QAA8B;AACrE,SAAO,SAAU,QAA6B,aAA8B,YAA8B;AACxG,QAAME,oBAAqC,IAAI,iBAAgB;AAC/D,QAAM,iBAAiB,WAAW;AAElC,eAAW,QAAQ,WAAA;AAAU,UAAA,OAAA,CAAA;eAAA,KAAA,GAAA,KAAA,UAAA,QAAA,MAAc;AAAd,aAAA,EAAA,IAAA,UAAA,EAAA;;AAC3B,UAAM,SAAc,eAAe,MAAM,MAAM,IAAI;AACnD,UAAMC,aACJ,CAAC,CAAC,WAAW,OAAO,WAAW,YAAY,OAAO,WAAW,eAAe,OAAO,OAAO,SAAS;AACrG,aAAOA,aACH,OAAO,KAAK,SAAC,MAAS;AAAK,eAAAD,kBAAiB,gBAAgB,MAAM,MAAM;MAA7C,CAA8C,IACzEA,kBAAiB,gBAAgB,QAAQ,MAAM;IACrD;EACF;AACF;;;ACdM,SAAU,yBACd,WACA,QAA8B;AAE9B,SAAO,SAAU,QAA6B,aAA8B,YAA8B;AACxG,QAAME,oBAAqC,IAAI,iBAAgB;AAC/D,QAAM,iBAAiB,WAAW;AAElC,eAAW,QAAQ,WAAA;AAAU,UAAA,OAAA,CAAA;eAAA,KAAA,GAAA,KAAA,UAAA,QAAA,MAAc;AAAd,aAAA,EAAA,IAAA,UAAA,EAAA;;AAC3B,UAAM,SAAc,eAAe,MAAM,MAAM,IAAI;AACnD,UAAMC,aACJ,CAAC,CAAC,WAAW,OAAO,WAAW,YAAY,OAAO,WAAW,eAAe,OAAO,OAAO,SAAS;AACrG,aAAOA,aACH,OAAO,KAAK,SAAC,MAAS;AAAK,eAAAD,kBAAiB,gBAAgB,WAAW,MAAM,MAAM;MAAxD,CAAyD,IACpFA,kBAAiB,gBAAgB,WAAW,QAAQ,MAAM;IAChE;EACF;AACF;;;ACjBM,SAAU,UACd,aACA,SAA8B;AAA9B,MAAA,YAAA,QAAA;AAAA,cAAA,CAAA;EAA8B;AAE9B,SAAO,SAAU,QAAa,cAA6B;AACzD,2BAAuB,qBAAqB;MAC1C,QAAQ,OAAO;MACf;MACA;MACA;KACD;EACH;AACF;;;ACXM,SAAU,KACd,cACA,SAAyB;AAAzB,MAAA,YAAA,QAAA;AAAA,cAAA,CAAA;EAAyB;AAEzB,SAAO,SAAU,QAAa,cAA6B;AACzD,QAAM,gBAAiB,QAAgB,YAAY,eAAe,QAAQ,YAAY;AACtF,2BAAuB,gBAAgB;MACrC,QAAQ,OAAO;MACf;MACA;MACA;MACA;KACD;EACH;AACF;;;ACdA,IAAM,mBAAmB,IAAI,iBAAgB;AASvC,SAAU,aACd,QACA,SAA+B;AAE/B,SAAO,iBAAiB,gBAAgB,QAAQ,OAAO;AACzD;AAOM,SAAU,gBACd,QACA,SAA+B;AAE/B,SAAO,iBAAiB,gBAAgB,QAAQ,OAAO;AACzD;AAmBM,SAAU,sBACd,QACA,aACA,SAA+B;AAE/B,SAAO,iBAAiB,sBAAsB,QAAQ,aAAa,OAAO;AAC5E;AASM,SAAU,aAAmB,KAA0B,OAAgB,SAA+B;AAC1G,SAAO,iBAAiB,gBAAgB,KAAK,OAAc,OAAO;AACpE;AAOM,SAAU,gBACd,KACA,OACA,SAA+B;AAE/B,SAAO,iBAAiB,gBAAgB,KAAK,OAAc,OAAO;AACpE;AAWM,SAAU,sBAA4B,WAAc,OAAgB,SAA+B;AACvG,SAAO,iBAAiB,sBAAsB,WAAW,OAAO,OAAO;AACzE;AAOM,SAAU,mBAAsB,QAAiB,SAA+B;AACpF,SAAO,iBAAiB,mBAAmB,QAAQ,OAAO;AAC5D;AAWM,SAAU,sBAAyB,QAAW,YAAqB,SAA+B;AACtG,SAAO,iBAAiB,sBAAsB,QAAQ,YAAY,OAAO;AAC3E;AAYM,SAAU,UAAa,QAAiB,SAA+B;AAC3E,SAAO,iBAAiB,UAAU,QAAQ,OAAO;AACnD;AAUM,SAAU,YAAe,KAA0B,MAAc,SAA+B;AACpG,SAAO,iBAAiB,YAAY,KAAK,MAAM,OAAO;AACxD;AAWM,SAAU,iBAAoB,KAA0B,MAAc,SAA+B;AACzG,SAAO,iBAAiB,iBAAiB,KAAK,MAAM,OAAO;AAC7D;",
  "names": ["TransformationType", "MetadataStorage", "TransformOperationExecutor", "key", "self", "ClassTransformer", "classTransformer", "isPromise", "classTransformer", "isPromise", "classTransformer", "isPromise"]
}
